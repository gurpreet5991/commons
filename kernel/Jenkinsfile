node {	
 def server = Artifactory.server 'ART'
 def rtMaven = Artifactory.newMavenBuild()
 def buildInfo
 def branch = 'DEV'
 projectToBuild = 'kernel'
 def registryUrl = 'http://docker-registry.mosip.io:5000'
 def registryName = 'docker-registry.mosip.io:5000'
 def registryCredentials = '305c7f35-2eb5-44b4-b574-a0855ef70c26'
 targetDeploymentServer = 'kernel-dev-server'
 updatedServices = []
 updatedDockerImages = []
 containersToRun = ''
 containerNames= ''

	
 stage('------- Checkout --------') {
  // Checkout only Kernel Module
  dir(branch) {
   checkout([$class: 'GitSCM',
    branches: [
     [name: branch]
    ],
    userRemoteConfigs: [
     [url: 'https://github.com/mosip/mosip', credentialsId: '4c9741a2-4c15-4aad-a13d-3a1206u05321']
    ],
    extensions: [

     [$class: 'PathRestriction', excludedRegions: '', includedRegions: projectToBuild + '/.*'],
     [$class: 'SparseCheckoutPaths', sparseCheckoutPaths: [
      [$class: 'SparseCheckoutPath', path: '/'+projectToBuild + '/']
     ]]

    ],
   ])
  }
 }

 stage('--------- Artifactory configuration ----------------') {
  rtMaven.tool = 'M2_HOME' // Tool name from Jenkins configuration
  rtMaven.deployer releaseRepo: 'libs-release-local', snapshotRepo: 'libs-snapshot-local', server: server
  rtMaven.resolver releaseRepo: 'libs-release', snapshotRepo: 'libs-snapshot', server: server
  buildInfo = Artifactory.newBuildInfo()
  buildInfo.env.capture = true
 }

 stage('---------- mvn-clean-install ---------------') {
  rtMaven.run pom: branch + '/' + projectToBuild + '/pom.xml', goals: 'clean install', buildInfo: buildInfo
 }

stage('---------- SonarQube Analysis --------------') {
  def mvnHome = tool name: 'M2_HOME', type: 'maven'
  withSonarQubeEnv('sonar') {
   sh "${mvnHome}/bin/mvn -f '$branch/$projectToBuild/' sonar:sonar"
  }
 }

 stage('----------- Publish build info -------------') {
  server.publishBuildInfo buildInfo
 }

  stage('------ Docker Images : Push & Cleanup -------') {
  if ("${env.BUIILD_OPTION}" == "Build All") {
   echo "BUILD_OPTION is set to Build All."
   echo "Building all submodules."

    dir(branch) {
      sh "find . -name 'Dockerfile'> directoryDockerFiles"
      locationOfDockerFiles = readFile("directoryDockerFiles").split("\\r?\\n");
      sh "rm -f directoryDockerFiles"
      Set servicesName = [] as TreeSet
      Set servicesPath = [] as TreeSet
      Set dockerFilesLocation = [] as TreeSet
       for (int i = 0; i < locationOfDockerFiles.size(); i++) {
        if(locationOfDockerFiles[i].equals("")){
        break;
        }
        def currentModule = locationOfDockerFiles[i]
        sh "basename `dirname $currentModule` > parentDirectoryName"
        parentDirectoryName = readFile('parentDirectoryName').trim()
        sh "rm -f parentDirectoryName"
        sh "dirname $currentModule > parentDirectoryPath"
        parentDirectoryPath = readFile('parentDirectoryPath').trim()
        sh "rm -f parentDirectoryPath"
        parentDirectoryPathFormatted = parentDirectoryPath.substring(2);
           servicesName.add(parentDirectoryName);
           servicesPath.add(parentDirectoryPathFormatted);
           dockerFilesLocation.add(currentModule);

      }

      for (int j = 0; j < servicesName.size(); j++) {
               def currentServiceName
               echo "Updating changed images list"
               updatedServices.add(servicesName[j])
               updatedDockerImages.add(registryName+'/'+servicesName[j]+":$BUILD_NUMBER")
               containersToRun=containersToRun+" "+registryName+'/'+servicesName[j]
               containerNames=containerNames+" "+servicesName[j]
               echo servicesPath[j] + " will be built"
               docker.withRegistry(registryUrl, registryCredentials) {
               def buildName = servicesName[j]+":$BUILD_NUMBER"
               newApp = docker.build(buildName, '-f ' + dockerFilesLocation[j] + ' ' + servicesPath[j])
               newApp.push()
               newApp.push 'latest'
               }
               currentServiceName = servicesName[j]
               sh "docker rmi $currentServiceName:$BUILD_NUMBER"
               sh "docker rmi $registryName/$currentServiceName:$BUILD_NUMBER"
               sh "docker rmi $registryName/$currentServiceName"
      }

     }

  } else {
   echo "BUILD_OPTION is set to Build Changed."
   echo "Building only changed submodules."
            dir(branch) {
      sh "find . -name 'Dockerfile'> directoryDockerFiles"
      locationOfDockerFiles = readFile("directoryDockerFiles").split("\\r?\\n");
      sh "rm -f directoryDockerFiles"
      changedModules = getChangedModules();
      Set modifiedServicesName = [] as TreeSet
      Set modifiedServicesPath = [] as TreeSet
      Set dockerFilesLocation = [] as TreeSet
      for (int j = 0; j < changedModules.size(); j++) {
       for (int i = 0; i < locationOfDockerFiles.size(); i++) {
        if(locationOfDockerFiles[i].equals("")){
        break;
        }
        def currentModule = locationOfDockerFiles[i]
        sh "basename `dirname $currentModule` > parentDirectoryName"
        parentDirectoryName = readFile('parentDirectoryName').trim()
        sh "rm -f parentDirectoryName"
        sh "dirname $currentModule > parentDirectoryPath"
        parentDirectoryPath = readFile('parentDirectoryPath').trim()
        sh "rm -f parentDirectoryPath"
        parentDirectoryPathFormatted = parentDirectoryPath.substring(2);
        if (changedModules[j].contains(parentDirectoryPathFormatted)) {
           modifiedServicesName.add(parentDirectoryName);
           modifiedServicesPath.add(parentDirectoryPathFormatted);
           dockerFilesLocation.add(currentModule)
       }
       }
      }

      for (int j = 0; j < modifiedServicesName.size(); j++) {
               def currentServiceName
               echo "Updating changed images list"
               updatedServices.add(modifiedServicesName[j])
               updatedDockerImages.add(registryName+'/'+modifiedServicesName[j]+":$BUILD_NUMBER")
               containersToRun=containersToRun+" "+registryName+'/'+modifiedServicesName[j]
               containerNames=containerNames+" "+modifiedServicesName[j]
               echo modifiedServicesPath[j] + " will be built"
               docker.withRegistry(registryUrl, registryCredentials) {
               def buildName = modifiedServicesName[j]+":$BUILD_NUMBER"
               newApp = docker.build(buildName, '-f ' + dockerFilesLocation[j] + ' ' + modifiedServicesPath[j])
               newApp.push()
               newApp.push 'latest'
               }
               currentServiceName = modifiedServicesName[j]
               sh "docker rmi $currentServiceName:$BUILD_NUMBER"
               sh "docker rmi $registryName/$currentServiceName:$BUILD_NUMBER"
               sh "docker rmi $registryName/$currentServiceName"
      }

     }
  }

 }
  stage('----deploy in dev----')
 {
	  command = """
 		INDEX=0
		containersToRunShell=(${containersToRun})
		containerNamesShell=(${containerNames})
		
 		for i in "\${containersToRunShell[@]}"
			do
			  echo "Deploying Service - " \$i
			  docker pull \$i
			  portExposed="\$(docker inspect --format='{{range \$p, \$conf := .Config.ExposedPorts}} {{index (split \$p "/") 0}} {{end}}' \$i)"
			  portExposedFormatted="\$(echo \$portExposed| xargs)"
			  echo Container will expose services on \$portExposedFormatted 
			  volumeMounted="\$(docker inspect --format='{{range \$p, \$conf := .Config.Volumes}} {{ \$p }} {{end}}' \$i)"
			  portExposedFormatted="\$(echo \$portExposed| xargs)"
			 if [ "\$(docker ps -a | grep \${containerNamesShell[\$INDEX]})" ]; then
			  docker rename \${containerNamesShell[\$INDEX]} \${containerNamesShell[\$INDEX]}-backup && docker stop \${containerNamesShell[\$INDEX]}-backup
			 fi
			  if [ "\$volumeMounted" = "" ]; then 
					echo "No volume to mount" 
					 docker run -d -e active_profile_env=dev -p \$portExposedFormatted:\$portExposedFormatted --name "\${containerNamesShell[\$INDEX]}" \$i
					  if [ \$? -eq 0 ]; then
						echo Container Started - \${containerNamesShell[\$INDEX]}
						if [ "\$(docker ps -a | grep \${containerNamesShell[\$INDEX]}-backup)" ]; then
							echo Removing Backed up container - \${containerNamesShell[\$INDEX]}-backup
							docker rm \${containerNamesShell[\$INDEX]}-backup
						fi
					  else
						echo Error - Cannot start new container, rollbacking to previous container
						docker start \${containerNamesShell[\$INDEX]}-backup && docker rename \${containerNamesShell[\$INDEX]}-backup \${containerNamesShell[\$INDEX]}
					  fi
			  else
					echo "Volume to me mounted : \$volumeMounted" 
					currentDirectory=\$(echo \$(pwd))
					volumeMountedFormatted="\$(echo \$volumeMounted| xargs)"
					 docker run -d -v \$currentDirectory\$volumeMountedFormatted:\$volumeMountedFormatted -e active_profile_env=dev -p \$portExposedFormatted:\$portExposedFormatted --name "\${containerNamesShell[\$INDEX]}" \$i
					  if [ \$? -eq 0 ]; then
						echo Container Started - \${containerNamesShell[\$INDEX]}
						if [ "\$(docker ps -a | grep \${containerNamesShell[\$INDEX]}-backup)" ]; then
							echo Removing Backed up container - \${containerNamesShell[\$INDEX]}-backup
							docker rm \${containerNamesShell[\$INDEX]}-backup
						fi
					  else
						echo Error - Cannot start new container, rollbacking to previous container
						docker start \${containerNamesShell[\$INDEX]}-backup && docker rename \${containerNamesShell[\$INDEX]}-backup \${containerNamesShell[\$INDEX]}
					  fi					
			  fi;
			  let INDEX=\${INDEX}+1
			done
			
			if [ "\$(docker images | grep  '<none>')" ]; then
				echo Removing all untagged images
				docker rmi \$(docker images | awk '/<none>/ {print \$3}')
			fi
            echo Deployment process completed
    """
  sshPublisher(publishers: [sshPublisherDesc(configName: targetDeploymentServer, transfers: [sshTransfer(execCommand: "$command")])])
    }

}


@NonCPS
def getChangedModules() {
 Set changedModules = [] as TreeSet
 def changeLogSets = currentBuild.changeSets
 for (int i = 0; i < changeLogSets.size(); i++) {
  def entries = changeLogSets[i].items
  for (int j = 0; j < entries.length; j++) {
   def entry = entries[j]
   echo "${entry.commitId} by ${entry.author} on ${new Date(entry.timestamp)}: ${entry.msg}"
   def paths = new ArrayList(entry.affectedPaths)
   for (int k = 0; k < paths.size(); k++) {
    def path = paths[k]
    if (path.startsWith(projectToBuild)) {
     changedModules.add(path);
    }

   }
  }
 }
 echo "Changed modules are ::::::::::> "+changedModules
 return changedModules
}
